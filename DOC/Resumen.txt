# üìã **FLUJO COMPLETO DE FUNCIONAMIENTO - VPC3+S PROFIBUS SLAVE**

## üìù **RESUMEN EJECUTIVO Y ESTADO ACTUAL (NUEVO)**

El sistema implementa un esclavo PROFIBUS DP usando un microcontrolador STM32 y el ASIC VPC3+S. El objetivo es establecer una comunicaci√≥n estable con un PLC master, intercambiando 1 byte de entrada y 1 byte de salida.

**Estado Actual:**
- **Firmware del Esclavo (STM32): ¬°Corregido y Funcional!** Se ha solucionado un error cr√≠tico de flujo l√≥gico en `DpAppl.c` que imped√≠a que la l√≥gica de aplicaci√≥n se ejecutara en el momento correcto. El esclavo ahora procesa correctamente la configuraci√≥n del master (`Chk_Cfg`), entra en `DATA_EXCHANGE`, prepara la aplicaci√≥n (`ApplicationReady`) y procesa la primera trama de datos de forma exitosa.
- **Comportamiento del Master (PLC): An√≥malo e Inestable.** El problema principal ahora reside en el PLC. Inmediatamente despu√©s del primer intercambio de datos exitoso, el master env√≠a una trama de reconfiguraci√≥n inv√°lida y corrupta (de 123 bytes en lugar de 2), lo que causa un error fatal en el chip VPC3+S y detiene la comunicaci√≥n.

**Pr√≥ximos Pasos:** El enfoque se traslada al **100% al diagn√≥stico del PLC y de la capa f√≠sica de la red PROFIBUS** para resolver la inestabilidad del master.

---

## üîß **1. INICIALIZACI√ìN DEL SISTEMA**

### **1.1 Archivo Principal: `main.c`**

```c
int main(void)
{
    // 1. Inicializaci√≥n HAL y perif√©ricos
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_USART2_UART_Init();
    MX_SPI1_Init();
    
    // 2. Reset hardware del VPC3+S
    HAL_GPIO_WritePin(VPC3_RESET_PORT, VPC3_RESET_PIN, GPIO_PIN_RESET);
    HAL_Delay(10);
    HAL_GPIO_WritePin(VPC3_RESET_PORT, VPC3_RESET_PIN, GPIO_PIN_SET);
    HAL_Delay(50);
    
    // 3. Forzar estado OFFLINE
    Vpc3Write(0x08, 0x04);  // GO_OFFLINE command
    HAL_Delay(20);
    
    // 4. Inicializaci√≥n PROFIBUS
    DpAppl_ProfibusInit();
    
    // 5. Bucle principal
    while(1) {
        DpAppl_ProfibusMain();
        HAL_Delay(1);
    }
}
```

### **1.2 Secuencia de Inicializaci√≥n:**

| **Paso** | **Funci√≥n** | **Archivo** | **Descripci√≥n** |
|----------|-------------|-------------|-----------------|
| 1 | `HAL_Init()` | STM32 HAL | Inicializaci√≥n del hardware STM32 |
| 2 | `SystemClock_Config()` | `main.c` | Configuraci√≥n del reloj del sistema |
| 3 | `MX_GPIO_Init()` | `main.c` | Configuraci√≥n de GPIO (RESET, SPI) |
| 4 | `MX_SPI1_Init()` | `main.c` | Configuraci√≥n SPI para VPC3+S |
| 5 | `MX_USART2_UART_Init()` | `main.c` | Configuraci√≥n UART para debug |

---

## üîÑ **2. INICIALIZACI√ìN PROFIBUS**

### **2.1 Funci√≥n Principal: `DpAppl_ProfibusInit()`**

**Archivo:** `Core/Src/DpAppl.c`

```c
void DpAppl_ProfibusInit(void)
{
    // 1. Inicializar estructuras de datos
    memset(&sDpAppl, 0, sizeof(sDpAppl));
    memset(&sSystem, 0, sizeof(STRUC_SYSTEM));
    sSystem.bNrOfModules = MaxModule;
    
    // 2. Configurar punteros VPC3
    pVpc3 = &sVpc3OnlyForInit;
    pDpSystem = &sDpSystemChannel1;
    memset(pVpc3, 0, sizeof(VPC3_STRUC));
    
    // 3. Inicializar m√≥dulos PROFIBUS
    DpPrm_Init();    // Par√°metros
    DpCfg_Init();    // Configuraci√≥n
    DpDiag_Init();   // Diagn√≥sticos
    
    // 4. Test de memoria VPC3
    bError = VPC3_MemoryTest();
    
    // 5. Inicializaci√≥n VPC3
    bError = VPC3_Initialization(DP_ADDR, IDENT_NR, &sDpAppl.sCfgData);
    
    // 6. Arrancar VPC3
    VPC3_Start();
}
```

### **2.2 Secuencia de Inicializaci√≥n PROFIBUS:**

| **Paso** | **Funci√≥n** | **Archivo** | **Descripci√≥n** |
|----------|-------------|-------------|-----------------|
| 1 | `DpPrm_Init()` | `Core/Src/DpPrm.c` | Inicializaci√≥n de par√°metros |
| 2 | `DpCfg_Init()` | `Core/Src/DpCfg.c` | Inicializaci√≥n de configuraci√≥n |
| 3 | `DpDiag_Init()` | `Core/Src/DpDiag.c` | Inicializaci√≥n de diagn√≥sticos |
| 4 | `VPC3_MemoryTest()` | `Core/Src/dp_if.c` | Test de memoria VPC3+S |
| 5 | `VPC3_Initialization()` | `Core/Src/dp_if.c` | Configuraci√≥n del chip VPC3+S |
| 6 | `VPC3_Start()` | `Core/Src/dp_if.c` | Arranque del VPC3+S |

---

## ‚öôÔ∏è **3. CONFIGURACI√ìN DEL VPC3+S**

### **3.1 Funci√≥n: `VPC3_Initialization()`**

**Archivo:** `Core/Src/dp_if.c`

```c
DP_ERROR_CODE VPC3_Initialization(uint8_t bSlaveAddr, uint16_t wIdentNr, psCFG psCfgData)
{
    // 1. Verificar estado OFFLINE
    if (!(Vpc3Read(0x04) & 0x01)) {
        printf("VPC3 esta en OFFLINE, continuando...\n");
    }
    
    // 2. Configurar MODE_REG_2
    Vpc3Write(bVpc3WoModeReg2, INIT_VPC3_MODE_REG_2);
    
    // 3. Limpiar memoria VPC3
    memset(pVpc3, 0, ASIC_RAM_LENGTH);
    
    // 4. Configurar valores constantes
    VPC3_SetConstants();
    
    // 5. Calcular longitudes I/O
    VPC3_CalculateIoLengths();
    
    // 6. Inicializar buffers
    VPC3_InitializeBuffers();
    
    // 7. Configurar servicios
    VPC3_ConfigureServices();
    
    // 8. Copiar configuraci√≥n
    VPC3_CopyConfiguration(psCfgData);
    
    return DP_OK;
}
```

### **3.2 Funci√≥n: `VPC3_Start()`**

**Archivo:** `Core/Src/dp_if.c`

```c
void VPC3_Start(void)
{
    // 1. Verificar estado antes del START
    uint8_t pre_start_status = Vpc3Read(0x04);
    
    // 2. Enviar comando START
    Vpc3Write(0x08, 0x01);  // START command
    HAL_Delay(50);
    
    // 3. Estabilizaci√≥n adicional
    HAL_Delay(500);
    
    // 4. Reconfigurar registros de modo
    Vpc3Write(bVpc3RwModeReg0_H, INIT_VPC3_MODE_REG_H);
    Vpc3Write(bVpc3RwModeReg0_L, INIT_VPC3_MODE_REG_L);
    Vpc3Write(bVpc3WoModeReg2, INIT_VPC3_MODE_REG_2);
    Vpc3Write(bVpc3WoModeReg3, INIT_VPC3_MODE_REG_3);
    
    // 5. Verificar transici√≥n a PASSIVE_IDLE
    uint8_t post_start_status = Vpc3Read(0x04);
}
```

---

## üíª **4. BUCLE PRINCIPAL DE OPERACI√ìN (ACTUALIZADO CON L√ìGICA CORREGIDA)**

### **4.1 Funci√≥n Principal: `DpAppl_ProfibusMain()`**

**Archivo:** `Core/Src/DpAppl.c`

**NOTA:** Esta secci√≥n ha sido actualizada para mostrar la **l√≥gica corregida**, que soluciona el error de flujo que imped√≠a el intercambio de datos. El cambio clave es mover la llamada a `DpAppl_ApplicationReady()` para que se ejecute inmediatamente al entrar en `DATA_EX`. El c√≥digo original ha sido reemplazado por esta versi√≥n m√°s detallada que refleja el estado funcional actual.

```c
void DpAppl_ProfibusMain(void)
{
    // 1. Trigger watchdogs
    VPC3_RESET_USER_WD();
    
    // 2. Poll PROFIBUS events
    #if VPC3_SERIAL_MODE
       VPC3_Poll();
    #endif
    
    // 3. Process DP-V1 state machines
    VPC3_ProcessDpv1StateMachine();
    
    // 4. Internal state machine
    if (VPC3_GetDpState(eDpStateInit)) {
        // Clear data and set run state
        VPC3_ClrDpState(eDpStateInit);
        VPC3_SetDpState(eDpStateRun);
    }
    
    // 5. VPC3+ DP-state processing
    #if VPC3_SERIAL_MODE
        uint8_t bStatusRegHigh = VPC3_GET_STATUS_H();
        uint8_t bStatusRegLow = VPC3_GET_STATUS_L();
        uint8_t bDpState = ((bStatusRegLow & MASK_DP_STATE) >> 5);
        
        // 6. State machine switch
        switch(bDpState) {
            case WAIT_PRM:
                // Esperar telegrama Prm
                break;
            case WAIT_CFG:
                // Esperar telegrama Chk_Cfg
                break;
            case DATA_EX:
                // --- INICIO DE LA L√ìGICA CORREGIDA ---
                // Al entrar por PRIMERA VEZ, preparamos la aplicaci√≥n
                if (VPC3_GetDpState(eDpStateCfgOkStatDiag)) {
                    printf("DEBUG: [DATA_EX] Condici√≥n para llamar a ApplicationReady CUMPLIDA. Llamando...\n");
                    DpAppl_ApplicationReady();
                }
            
                // Si la aplicaci√≥n est√° lista, intercambiamos datos
                if (VPC3_GetDpState(eDpStateApplReady) && VPC3_GetDpState(eDpStateRun)) {
                    // L√≥gica de aplicaci√≥n (Eco de datos)
                    uint8_t byte_from_plc = sSystem.sOutput.abDo8[0];
                    uint8_t byte_to_plc = byte_from_plc + 100;
                    sSystem.sInput.abDi8[0] = byte_to_plc;
                    DpAppl_SetApplEvent(eDpApplEv_IoIn);
                }
                // --- FIN DE LA L√ìGICA CORREGIDA ---
                break;
            case DP_ERROR:
                // Error de protocolo
                DpAppl_FatalError(_DP_USER, __LINE__, &sVpc3Error);
                break;
        }
        
        // Procesar datos de salida (Master -> Esclavo) si hay un evento
        DpAppl_CheckEvIoOut();
    #endif
}
```

---

## ‚ö° **5. PROCESAMIENTO DE EVENTOS PROFIBUS**

### **5.1 Funci√≥n: `VPC3_Poll()`**

**Archivo:** `Core/Src/dp_isr.c`

```c
void VPC3_Poll(void)
{
    // 1. Leer registros de interrupci√≥n
    uint8_t bIntRegLow = Vpc3Read(bVpc3RoIntRegL);
    uint8_t bIntRegHigh = Vpc3Read(bVpc3RoIntRegH);
    
    // 2. Procesar interrupciones
    if (bIntRegLow & IND_DX_OUT) {
        // Data Exchange Output
        DpAppl_IsrDxOut();
        VPC3_CON_IND_DX_OUT();
    }
    
    if (bIntRegLow & IND_GO_LEAVE_DATA_EX) {
        // Go/Leave Data Exchange
        DpAppl_IsrGoLeaveDataExchange(VPC3_GET_DP_STATE());
        VPC3_CON_IND_GO_LEAVE_DATA_EX();
    }
    
    // ... otros eventos
}
```

### **5.2 Funci√≥n: `DpAppl_IsrDxOut()`**

**Archivo:** `Core/Src/DpAppl.c`

```c
void DpAppl_IsrDxOut(void)
{
    // Configurar evento IoOut para procesamiento en el bucle principal
    // NOTA: El nombre original era sDpAppl.bIoOutEvent, se unific√≥ a usar DpAppl_SetApplEvent
    DpAppl_SetApplEvent(eDpApplEv_IoOut);
}
```

---

## ‚úîÔ∏è **6. CONFIGURACI√ìN Y VALIDACI√ìN**

### **6.1 Funci√≥n: `DpCfg_ChkNewCfgData()`**

**Archivo:** `Core/Src/DpCfg.c`

```c
E_DP_CFG_ERROR DpCfg_ChkNewCfgData(MEM_UNSIGNED8_PTR pbCfgData, uint8_t bCfgLength)
{
    // 1. Copia local defensiva
    uint8_t localCfgBuffer[LOCAL_CFG_MAX];
    uint8_t localLen = (bCfgLength < LOCAL_CFG_MAX) ? bCfgLength : LOCAL_CFG_MAX;
    memcpy(localCfgBuffer, pbCfgData, localLen);
    
    // 2. Validar longitud
    uint8_t bRealCfgLength = pDpSystem->bOutputDataLength + pDpSystem->bInputDataLength;
    if (bCfgLength != bRealCfgLength) {
        return DP_CFG_FAULT;
    }
    
    // 3. Comparar configuraci√≥n
    if (memcmp(sDpAppl.sCfgData.abData, localCfgBuffer, bRealCfgLength) != 0) {
        return DP_CFG_FAULT;
    }
    
    // 4. Configuraci√≥n OK, configurar diagn√≥sticos y levantar flag de estado
    E_DP_CFG_ERROR eRetValue = DpDiag_SetCfgOk(DP_CFG_OK);
    if (eRetValue != DP_CFG_FAULT) {
        VPC3_SetDpState(eDpStateCfgOkStatDiag);
    }
    
    return eRetValue;
}
```

---

## üîç **7. DIAGN√ìSTICOS**

### **7.1 Funci√≥n: `DpDiag_SetCfgOk()`**

**Archivo:** `Core/Src/DpDiag.c`

```c
E_DP_CFG_ERROR DpDiag_SetCfgOk(E_DP_CFG_ERROR eCfgError)
{
    E_DP_CFG_ERROR eRetValue = eCfgError;
    uint8_t bLoop = 0;
    
    while (bLoop++ < MAX_DIAG_RETRY) {
        if (DpDiag_Alarm(USER_TYPE_CFG_OK, 0x22, VPC3_NULL_PTR, VPC3_FALSE) == DP_OK) {
            break;
        }
    }
    
    return eRetValue;
}
```

### **7.2 Funci√≥n: `DpDiag_Alarm()`**

**Archivo:** `Core/Src/DpDiag.c`

```c
DP_ERROR_CODE DpDiag_Alarm(uint8_t bAlarmType, uint8_t bSeqNr, 
                          ALARM_STATUS_PDU_PTR psAlarmStatus, uint8_t bCheckDiagFlag)
{
    // 1. Calcular evento de diagn√≥stico
    uint16_t wDiagEvent = ((uint16_t)bAlarmType << 8) | bSeqNr;
    
    // 2. Verificar si el diagn√≥stico cambi√≥
    if (wDiagEvent == pDpSystem->wOldDiag) {
        return DP_DIAG_SAME_DIAG;
    }
    
    // 3. Procesar tipo de alarma
    uint8_t bDiagLength = 0;
    uint8_t bExtDiagFlag = 0;
    switch (bAlarmType) {
        case USER_TYPE_CFG_OK:
            bExtDiagFlag = EXT_DIAG_SET;
            DpDiag_AddIdentRelDiagBlock(&bDiagLength);
            DpDiag_AddModuleStatDiagBlock(&bDiagLength);
            break;
        // ... otros casos
    }
    
    // 4. Enviar diagn√≥stico
    return VPC3_SetDiagnosis(bDiagLength, bExtDiagFlag, bCheckDiagFlag);
}
```

---

## üó∫Ô∏è **8. MAPA DE ARCHIVOS Y FUNCIONES**

(Contenido original sin cambios)

---

## üéØ **9. SECUENCIA DE ESTADOS (ACTUALIZADO Y VERIFICADO)**

### **9.1 Transiciones de Estado:**

Esta es la secuencia de estados **correcta y verificada** a trav√©s de los logs.

```
1. OFFLINE (STATUS_L = 0x00)
   ‚Üì VPC3_Start()
2. PASSIVE_IDLE (STATUS_L = 0x91)
   ‚Üì Master env√≠a Prm y Cfg
3. WAIT_CFG (bDpState = 0x01)
   ‚Üì Esclavo recibe Cfg correcta, llama a DpCfg_ChkNewCfgData() y levanta eDpStateCfgOkStatDiag
4. DATA_EX (bDpState = 0x02, STATUS_L = 0x45)
   ‚Üì DENTRO del mismo ciclo, se llama a DpAppl_ApplicationReady()
5. DATA_EX + ApplicationReady (eDpStateApplReady=4, eDpStateRun=2)
   ‚Üì La aplicaci√≥n lee sSystem.sOutput y escribe en sSystem.sInput
```

### **9.2 Estados de Aplicaci√≥n:**

```c
// Flags de estado internos en la estructura pDpSystem
eDpStateInit = 1;           // Inicializaci√≥n
eDpStateRun = 2;            // Ejecutando
eDpStateApplReady = 4;      // Aplicaci√≥n lista
eDpStateCfgOkStatDiag = 8;  // Configuraci√≥n OK, diagn√≥stico pendiente
```

---

## üîß **10. CONFIGURACI√ìN CLAVE**

(Contenido original sin cambios)

---

## üìä **11. AN√ÅLISIS DE LA EJECUCI√ìN ACTUAL (NUEVO)**

Esta secci√≥n reemplaza el "Resultado Final" anterior con un an√°lisis del √∫ltimo log, que muestra el **√©xito del firmware** y el **fallo del PLC**.

### **11.1 ¬°√âxito del Firmware!**

El log confirma que el flujo l√≥gico del esclavo es correcto:

```
// Log clave que muestra el √©xito
DEBUG: [STATE_ANALYSIS] Comparaci√≥n: bDpState=0x02 vs DATA_EX=0x02 (¬øiguales? S√ç)
DEBUG: [DATA_EX] Condici√≥n para llamar a ApplicationReady CUMPLIDA. Llamando...
DEBUG: [ApplicationReady] INICIO - Configurando aplicaci√≥n despu√©s de Chk_Cfg exitoso
DEBUG: [ApplicationReady] Estados configurados: eDpStateCfgOkStatDiag=0, eDpStateApplReady=4, eDpStateRun=2
DEBUG: [ApplicationReady] FIN - Aplicaci√≥n configurada
DEBUG: [STATE_DATA_EX] VPC3+ en DATA_EX - comunicaci√≥n activa
DEBUG: [STATE_CHECK] eDpStateApplReady=4, eDpStateRun=2
DEBUG: [APPLICATION_READY] Ambos estados activos - aplicaci√≥n funcionando
[DATA_EXCHANGE_TRAMA #1] PLC->STM32: 0x00 | STM32->PLC: 0x64
```

### **11.2 ¬°Fallo del PLC!**

Inmediatamente despu√©s de la trama exitosa, el PLC se comporta de forma err√°tica:

```
// El PLC intenta reconfigurar al esclavo sin motivo
[EVENT] Chk_Cfg recibido por el slave.

// Env√≠a una trama corrupta y de longitud incorrecta
DEBUG: [CopyFromVpc3] Lectura de 0x04F0, longitud 123
DEBUG: [CopyFromVpc3] Datos le√≠dos: 0x83 0x87 0x2D 0xD3 ... (basura)

// El chip VPC3+S se corrompe y el firmware lanza un error fatal
DEBUG: [STATUS_CHANGE] STATUS_L: 0x45 -> 0x10, STATUS_H: 0xE3 -> 0x99
DEBUG: [FATAL_CHECK] STATUS_L=0x10, STATUS_H=0x99, AT_MASK check=1 (ERROR FATAL)
=== FATAL ERROR DETECTED ===
```

### **11.3 Conclusi√≥n del An√°lisis**
El firmware del esclavo (STM32) es ahora robusto y funciona como se espera. El problema se ha aislado y se ha confirmado que reside en el comportamiento del PLC o en la capa f√≠sica de la red PROFIBUS.

---

## üöÄ **12. PR√ìXIMOS PASOS: DIAGN√ìSTICO DEL MASTER Y CAPA F√çSICA (NUEVO)**

El problema **ya no reside en el firmware del esclavo**. El foco se traslada 100% al PLC y a la red.

1.  **Limpieza de Configuraci√≥n del PLC:**
    - Eliminar el esclavo de la configuraci√≥n de hardware en TIA Portal/Step 7.
    - Descargar la configuraci√≥n vac√≠a al PLC para forzar un borrado de su memoria.
    - Volver a a√±adir el esclavo desde el GSD y configurar solo 1 byte de entrada y 1 de salida.
    - Descargar la nueva configuraci√≥n limpia.

2.  **Bajar Velocidad del Bus:**
    - En la configuraci√≥n de la red PROFIBUS del PLC, reducir la velocidad a la m√°s baja posible (ej. **93.75 kbps**). Esto aumenta la robustez frente a ruido y problemas de cableado. Si a baja velocidad funciona, el problema es f√≠sico.

3.  **Verificar la Capa F√≠sica:**
    - **Terminadores de Bus:** Asegurarse de que las resistencias de terminaci√≥n est√°n activadas **√∫nicamente** en los dos extremos f√≠sicos del cable PROFIBUS.
    - **Aislamiento:** Probar la comunicaci√≥n con un √∫nico cable corto (1-2m) conectando solo el PLC y el STM32, eliminando el resto de la planta como posible fuente de ruido.
    - **Calidad del Cable:** Usar un cable PROFIBUS certificado y verificar que no est√© da√±ado.
    - **Fuente de Alimentaci√≥n:** Asegurarse de que tanto el PLC como el STM32 tienen una fuente de alimentaci√≥n estable y bien referenciada a tierra.
